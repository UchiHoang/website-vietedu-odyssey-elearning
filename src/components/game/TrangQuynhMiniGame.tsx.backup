import { useState, useEffect, useCallback, useRef, useMemo } from "react";
import { useNavigate, useParams } from "react-router-dom";
import { Button } from "@/components/ui/button";
import { CutscenePlayer } from "./CutscenePlayer";
import { QuestionCard } from "./QuestionCard";
import { GameHud } from "./GameHud";
import { BadgeModal } from "./BadgeModal";
import { LevelSelection } from "./LevelSelection";
import { StoryIntro } from "./StoryIntro";
import { findActivityByRef as findActivityByRefLegacy, loadStory as loadStoryLegacy } from "@/utils/storyLoader";
import { useSupabaseProgress } from "@/hooks/useSupabaseProgress";
import { ArrowLeft, RotateCcw, Loader2 } from "lucide-react";
import { toast } from "sonner";

type GamePhase = "prologue" | "level-selection" | "cutscene" | "questions" | "complete";

type StoryFrame = {
  speaker?: string;
  text?: string;
  [key: string]: unknown;
};

type SimpleQuestion = {
  id?: string;
  prompt?: string;
  question?: string;
  choices?: string[];
  options?: string[]; // Legacy format (grade2)
  answer?: string;
  correctAnswer?: number;
  explanation?: string;
  type?: string;
  // Special game types
  pairs?: Array<{ left: string; right: string; leftImage?: string; rightImage?: string }>;
  dragItems?: Array<{ id: string; content: string; image?: string; correctSlot: string }>;
  dropSlots?: Array<{ id: string; label: string; image?: string }>;
  blanks?: Array<{ position: number; answer: string; placeholder?: string }>;
  countingItems?: Array<{ image: string; count: number }>;
  countingAnswer?: number;
  [key: string]: unknown; // Allow other fields
};

type SimpleActivity = {
  id: string;
  xpReward?: number;
  timerSec?: number;
  duration?: number;
  questions: SimpleQuestion[];
};

type SimpleStory = {
  meta?: { title?: string; description?: string };
  prologue?: StoryFrame[];
  nodes: Array<{
    id: string;
    title: string;
    badgeOnComplete?: string | null;
    activityRef: string;
    cutscene?: StoryFrame[];
    assets?: Record<string, unknown>;
  }>;
  activities?: SimpleActivity[];
};

type ThemeConfig = {
  primary?: string;
  secondary?: string;
  bg?: string;
  bannerUrl?: string;
  fontClass?: string;
};

interface TrangQuynhMiniGameProps {
  grade?: string;
  courseId?: string;
  storyLoader?: () => SimpleStory;
  theme?: ThemeConfig;
}

export const TrangQuynhMiniGame = ({ grade, courseId = "grade2-trangquynh", storyLoader, theme }: TrangQuynhMiniGameProps) => {
  const navigate = useNavigate();
  const urlParams = useParams();
  // Memoize story to prevent reloading on every render
    // Use the prop if provided, otherwise try to get from URL params
  const gradeFromUrl = urlParams.grade?.replace("grade", "");
  const finalGrade = grade || gradeFromUrl || "2";

  console.log("Final grade:", finalGrade); // Debug log

  const rootStyle = theme?.bg ? { background: theme.bg } : undefined;
  const bannerStyle = theme?.bannerUrl ? { backgroundImage: `url(${theme.bannerUrl})`, backgroundSize: "cover", backgroundPosition: "center" } : {};
  const story = useMemo<SimpleStory>(() => {
    if (storyLoader) return storyLoader();
    return loadStoryLegacy();
  }, [storyLoader]);
  const prologueSlides = useMemo(() => (story.prologue ?? []) as StoryFrame[], [story.prologue]);

  const { 
    progress, 
    isLoading, 
    completeStage, 
    unlockBadge, 
    updateCurrentNode, 
    resetProgress,
    fetchProgress 
  } = useSupabaseProgress();
  
  const [gamePhase, setGamePhase] = useState<GamePhase>("prologue");
  const [currentNodeIndex, setCurrentNodeIndex] = useState(0);
  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
  const [currentActivity, setCurrentActivity] = useState<SimpleActivity | null>(null);
  const [showBadgeModal, setShowBadgeModal] = useState(false);
  const [levelPerformance, setLevelPerformance] = useState<"excellent" | "good" | "retry">("good");
  const [earnedXpThisLevel, setEarnedXpThisLevel] = useState(0);
  const [completedBadgeId, setCompletedBadgeId] = useState<string | null>(null);
  const [timerSeconds, setTimerSeconds] = useState<number>(0);
  const [correctThisLevel, setCorrectThisLevel] = useState(0);
  const [incorrectThisLevel, setIncorrectThisLevel] = useState(0);
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  // Track time spent on level
  const levelStartTime = useRef<number>(Date.now());

  const currentNode = story.nodes[currentNodeIndex];
  const isGameComplete = currentNodeIndex >= story.nodes.length;

  const normalizeQuestion = useCallback(
    (q: SimpleQuestion, idx: number) => {
      // Support both formats:
      // New format: { prompt, choices, answer }
      // Legacy format (grade2): { question, options, correctAnswer }
      
      const questionText = q.question ?? q.prompt ?? "";
      const questionType = q.type || "multiple-choice";
      
      // For legacy format (grade2) - if it has options and correctAnswer as number, preserve as-is
      if (q.options && Array.isArray(q.options) && q.options.length > 0 && typeof q.correctAnswer === 'number') {
        // Legacy format - preserve all fields
        const normalized: Record<string, unknown> = {
          id: q.id ?? `${currentNode?.id || "q"}-${idx}`,
          question: questionText || q.question || "",
          options: q.options,
          correctAnswer: q.correctAnswer,
          explanation: q.explanation ?? "H√£y th·ª≠ l·∫°i l·∫ßn n·ªØa nh√©!",
          type: questionType as "multiple-choice" | "matching-pairs" | "drag-drop" | "fill-blank" | "counting",
        };
        
        // Preserve all other fields from original question
        Object.keys(q).forEach(key => {
          if (!normalized[key]) {
            normalized[key] = (q as Record<string, unknown>)[key];
          }
        });
        
        return normalized as SimpleQuestion & Record<string, unknown>;
      }
      
      // New format processing
      const choices = q.choices ?? q.options ?? [];
      
      // Determine correctAnswer index for multiple-choice
      let correctAnswerIndex = 0;
      if (typeof q.correctAnswer === 'number') {
        correctAnswerIndex = q.correctAnswer;
      } else if (q.answer && choices.length > 0) {
        correctAnswerIndex = choices.findIndex(c => c === q.answer);
        if (correctAnswerIndex === -1) correctAnswerIndex = 0;
      }
      
      // Base question object with proper typing
      const normalized: Record<string, unknown> = {
        id: q.id ?? `${currentNode?.id || "q"}-${idx}`,
        prompt: q.prompt ?? questionText,
        question: questionText,
        options: choices, // QuestionCard expects 'options'
        choices: choices,
        answer: q.answer ?? (choices[correctAnswerIndex] || ""),
        correctAnswer: correctAnswerIndex,
        explanation: q.explanation ?? "H√£y th·ª≠ l·∫°i l·∫ßn n·ªØa nh√©!",
        type: questionType as "multiple-choice" | "matching-pairs" | "drag-drop" | "fill-blank" | "counting",
      };
      
      // Preserve special fields for different game types
      if (questionType === "matching-pairs" && q.pairs) {
        normalized.pairs = q.pairs;
      }
      
      if (questionType === "drag-drop" && q.dragItems && q.dropSlots) {
        normalized.dragItems = q.dragItems;
        normalized.dropSlots = q.dropSlots;
      }
      
      if (questionType === "fill-blank" && q.blanks) {
        normalized.blanks = q.blanks;
      }
      
      if (questionType === "counting" && q.countingItems && q.countingAnswer !== undefined) {
        normalized.countingItems = q.countingItems;
        normalized.countingAnswer = q.countingAnswer;
      }
      
      return normalized as SimpleQuestion & Record<string, unknown>;
    },
    [currentNode?.id]
  );

  const getActivity = useCallback((activityRef?: string | null) => {
    if (!activityRef) {
      console.warn("No activityRef provided");
      return null;
    }
    
    if (story.activities && story.activities.length > 0) {
      const found = story.activities.find((a) => a.id === activityRef);
      if (found) {
        console.log("Activity found:", activityRef, "Questions:", found.questions?.length);
        return found;
      }
      console.warn("Activity not found in story.activities:", activityRef, "Available:", story.activities.map(a => a.id));
    }
    
    console.log("Trying legacy loader for:", activityRef);
    return findActivityByRefLegacy(activityRef);
  }, [story.activities]);

  // Initialize from Supabase progress
  useEffect(() => {
    if (!isLoading && progress.currentNode >= 0) {
      setCurrentNodeIndex(progress.currentNode);
    }
  }, [isLoading, progress.currentNode]);

  // Memoize activity loading to prevent repeated lookups
  const loadedActivity = useMemo(() => {
    if (currentNode?.activityRef) {
      return getActivity(currentNode.activityRef);
    }
    return null;
}, [currentNode?.activityRef, getActivity]);

  useEffect(() => {
    if (currentNode && gamePhase === "cutscene") {
      setCurrentActivity(loadedActivity as SimpleActivity);
      levelStartTime.current = Date.now();
    }
  }, [currentNode, gamePhase, loadedActivity]);

  // Ensure currentActivity is preserved when moving to next question
  useEffect(() => {
    if (gamePhase === "questions" && currentNode && !currentActivity) {
      console.warn("Activity lost, reloading...");
      const activity = getActivity(currentNode.activityRef);
      if (activity) {
        setCurrentActivity(activity as SimpleActivity);
      }
    }
  }, [gamePhase, currentNode, currentActivity, getActivity]);

  const handlePrologueComplete = () => {
    setGamePhase("level-selection");
  };

  const handleSelectLevel = async (nodeIndex: number) => {
    console.log("Selected level:", nodeIndex, "Node:", story.nodes[nodeIndex]);
    setCurrentNodeIndex(nodeIndex);
    setCurrentQuestionIndex(0);
    setCorrectThisLevel(0);
    setIncorrectThisLevel(0);
    setEarnedXpThisLevel(0);
    levelStartTime.current = Date.now();
    
    // Pre-load activity
    const node = story.nodes[nodeIndex];
    if (node?.activityRef) {
      const activity = getActivity(node.activityRef);
      if (activity) {
        console.log("Pre-loaded activity:", activity.id, "Questions:", activity.questions?.length);
        setCurrentActivity(activity as SimpleActivity);
      }
    }
    
    await updateCurrentNode(nodeIndex);
    setGamePhase("cutscene");
  };

  const handleTimeUp = useCallback(() => {
    toast.error("H·∫øt gi·ªù! Th·ªùi gian ƒë√£ h·∫øt, h√£y th·ª≠ l·∫°i nh√©!");
    setLevelPerformance("retry");
    setShowBadgeModal(true);
  }, []);

  const handleCutsceneComplete = () => {
    const activity = getActivity(currentNode?.activityRef || "");
    setCurrentActivity(activity as SimpleActivity);
    setTimerSeconds(activity?.timerSec || activity?.duration || 120);
    setGamePhase("questions");
  };

  const handleCutsceneSkip = () => {
    const activity = getActivity(currentNode?.activityRef || "");
    setCurrentActivity(activity as SimpleActivity);
    setTimerSeconds(activity?.timerSec || activity?.duration || 120);
    setGamePhase("questions");
  };

  const handleAnswer = async (isCorrect: boolean) => {
    if (isSubmitting) return;
    
    const xpReward = currentActivity?.xpReward || 10;
    const totalQuestions = currentActivity?.questions.length || 1;
    
    // T√≠nh to√°n ch√≠nh x√°c s·ªë c√¢u ƒë√∫ng/sai sau khi tr·∫£ l·ªùi c√¢u n√†y
    let newCorrect: number;
    let newIncorrect: number;
    
    if (isCorrect) {
      newCorrect = correctThisLevel + 1;
      newIncorrect = incorrectThisLevel;
      setEarnedXpThisLevel(prev => prev + xpReward);
      setCorrectThisLevel(newCorrect);
      toast.success(`Ch√≠nh x√°c! +${xpReward} XP`);
    } else {
      newCorrect = correctThisLevel;
      newIncorrect = incorrectThisLevel + 1;
      setIncorrectThisLevel(newIncorrect);
    }
    
    // Ki·ªÉm tra xem ƒë√£ ho√†n th√†nh t·∫•t c·∫£ c√¢u h·ªèi ch∆∞a
    const isLastQuestion = currentQuestionIndex + 1 >= totalQuestions;
    
    if (isLastQuestion) {
      // Level complete - submit to backend
      setIsSubmitting(true);
      
      try {
        const timeSpent = Math.floor((Date.now() - levelStartTime.current) / 1000);
        const score = newCorrect * xpReward;
        const maxScore = totalQuestions * xpReward;
        
      const result = await completeStage(
        currentNode?.id || `stage-${currentNodeIndex}`,
        courseId,
        score,
        maxScore,
        newCorrect,
        totalQuestions,
        timeSpent
      );
        
        if (result?.success) {
          let performance: "excellent" | "good" | "retry";
          if (result.accuracy >= 90) {
            performance = "excellent";
          } else if (result.accuracy >= 60) {
            performance = "good";
          } else {
            performance = "retry";
          }
          
          setLevelPerformance(performance);
          setEarnedXpThisLevel(result.xpEarned);
          
          // Refresh progress to ensure UI is up to date
          await fetchProgress();
          
          // Award badge if passed
          if (performance !== "retry" && currentNode?.badgeOnComplete) {
            try {
              const badgeResult = await unlockBadge(
                currentNode.badgeOnComplete,
                currentNode.title,
                `Ho√†n th√†nh: ${currentNode.title}`,
                'üèÜ'
              );
              setCompletedBadgeId(badgeResult?.success ? currentNode.badgeOnComplete : null);
            } catch (badgeError) {
              console.error('Error unlocking badge:', badgeError);
              setCompletedBadgeId(null);
            }
          } else {
            setCompletedBadgeId(null);
          }
          
          setShowBadgeModal(true);
        } else {
          toast.error("Kh√¥ng th·ªÉ l∆∞u k·∫øt qu·∫£ (ch∆∞a ghi v√†o t√†i kho·∫£n). Vui l√≤ng th·ª≠ l·∫°i.");
        }
      } catch (error) {
        console.error('Error completing stage:', error);
        toast.error("ƒê√£ x·∫£y ra l·ªói khi l∆∞u k·∫øt qu·∫£. Vui l√≤ng th·ª≠ l·∫°i.");
      } finally {
        setIsSubmitting(false);
      }
    } else {
      setCurrentQuestionIndex(prev => prev + 1);
    }
  };

  const handleBadgeModalContinue = async () => {
    setShowBadgeModal(false);
    setEarnedXpThisLevel(0);
    setCurrentQuestionIndex(0);
    setCorrectThisLevel(0);
    setIncorrectThisLevel(0);
    
    if (currentNodeIndex + 1 >= story.nodes.length) {
      setGamePhase("complete");
    } else if (levelPerformance !== "retry") {
      const newIndex = currentNodeIndex + 1;
      setCurrentNodeIndex(newIndex);
      await updateCurrentNode(newIndex);
      setGamePhase("level-selection");
    } else {
      // Retry - stay on questions
      levelStartTime.current = Date.now();
      setGamePhase("questions");
    }
  };

  const handleRetry = () => {
    setShowBadgeModal(false);
    setEarnedXpThisLevel(0);
    setCurrentQuestionIndex(0);
    setCorrectThisLevel(0);
    setIncorrectThisLevel(0);
    levelStartTime.current = Date.now();
    setGamePhase("cutscene");
  };

  const handleExit = () => {
    navigate("/");
  };

  const handleRestart = async () => {
    await resetProgress();
    setCurrentNodeIndex(0);
    setCurrentQuestionIndex(0);
    setGamePhase("level-selection");
    setEarnedXpThisLevel(0);
    await fetchProgress();
  };

  const handleBackToLevelSelection = () => {
    setGamePhase("level-selection");
  };

  // Loading state
  if (isLoading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-background" style={rootStyle}>
        <div className="flex flex-col items-center gap-4">
          <Loader2 className="h-12 w-12 animate-spin text-primary" />
          <p className="text-muted-foreground">ƒêang t·∫£i ti·∫øn ƒë·ªô...</p>
        </div>
      </div>
    );
  }

  // Prologue Phase
  if (gamePhase === "prologue") {
    return <StoryIntro prologue={prologueSlides as unknown as []} onComplete={handlePrologueComplete} />;
  }

  // Level Selection Phase - use progress from Supabase
  if (gamePhase === "level-selection") {
    // Convert Supabase progress to format expected by LevelSelection
    const gameEngineProgress = {
      currentNodeIndex,
      completedNodes: progress.completedNodes,
      totalXp: progress.xp,
      earnedBadges: progress.earnedBadges,
      currentQuestionIndex: 0,
      correctAnswers: 0,
      incorrectAnswers: 0,
    };

    return (
      <div className="min-h-screen" style={rootStyle}>
        <div className="fixed top-24 right-6 z-50">
          <Button 
            onClick={handleExit} 
            size="sm"
            variant="outline"
            className="gap-2 bg-sky-50 hover:bg-sky-100 text-sky-700 border-sky-200 backdrop-blur-sm shadow-sm"
          >
            <ArrowLeft className="w-4 h-4" />
            Quay v·ªÅ
          </Button>
        </div>
        <LevelSelection
          title={story.meta?.title}
          description={story.meta?.description}
          nodes={story.nodes as unknown as []}
          progress={gameEngineProgress}
          onSelectLevel={handleSelectLevel}
        />
      </div>
    );
  }

  // Game Complete Phase
  if (gamePhase === "complete" || isGameComplete) {
    return (
      <div className="min-h-screen bg-gradient-to-b from-background to-primary/5 flex items-center justify-center p-4" style={rootStyle}>
        <div className="max-w-2xl w-full text-center space-y-8 animate-fade-in">
          <div className="space-y-4">
            <h1 className="text-4xl md:text-5xl font-heading font-bold text-primary">
              üéâ Ch√∫c m·ª´ng!
            </h1>
             <p className="text-xl text-muted-foreground">
              {finalGrade === "5"
                ? "B·∫°n ƒë√£ ho√†n th√†nh b·∫£o v·ªá ƒë·∫•t n∆∞·ªõc c√πng Tr·∫°ng Nguy√™n!"
                : finalGrade === "1"
                ? "B·∫°n ƒë√£ ho√†n th√†nh cu·ªôc ƒëua c√πng 12 con gi√°p!"
                : "B·∫°n ƒë√£ ho√†n th√†nh h√†nh tr√¨nh ƒë·∫øm b√°nh ch∆∞ng c√πng ch√∫ Cu·ªôi!"}
            </p>
          </div>

          <div className="bg-card rounded-xl p-8 shadow-lg space-y-6">
            <div className="grid grid-cols-3 gap-4 text-center">
              <div className="bg-primary/10 rounded-lg p-4">
                <div className="text-3xl font-bold text-primary">{progress.xp}</div>
                <div className="text-sm text-muted-foreground">T·ªïng XP</div>
              </div>
              <div className="bg-primary/10 rounded-lg p-4">
                <div className="text-3xl font-bold text-primary">{progress.level}</div>
                <div className="text-sm text-muted-foreground">C·∫•p ƒë·ªô</div>
              </div>
              <div className="bg-primary/10 rounded-lg p-4">
                <div className="text-3xl font-bold text-primary">{progress.earnedBadges.length}</div>
                <div className="text-sm text-muted-foreground">Huy hi·ªáu</div>
              </div>
            </div>

            <div className="flex gap-4">
              <Button onClick={handleRestart} variant="outline" className="flex-1 gap-2">
                <RotateCcw className="w-4 h-4" />
                Ch∆°i l·∫°i
              </Button>
              <Button onClick={handleExit} className="flex-1 gap-2">
                <ArrowLeft className="w-4 h-4" />
                Quay v·ªÅ
              </Button>
            </div>
          </div>
        </div>
      </div>
    );
  }

  // Cutscene Phase
  if (gamePhase === "cutscene" && currentNode) {
    const enhancedFrames = currentNode.cutscene?.map((frame: StoryFrame, idx) => {
      let sprite = undefined;
      
      if (frame.speaker === "Tr·∫°ng Qu·ª≥nh" || frame.speaker.includes("Qu·ª≥nh")) {
        const isExcited = frame.text.includes("!") || frame.text.includes("th√≠ch");
        sprite = isExcited 
          ? (currentNode.assets?.sprite_main_cheer || "assets/user/trang_cheer.png")
          : (currentNode.assets?.sprite_main_idle || "assets/user/trang_idle.png");
      } else if (frame.speaker !== "Ng∆∞·ªùi k·ªÉ chuy·ªán") {
        sprite = currentNode.assets?.sprite_main_idle || "assets/user/trang_portrait.png";
      }
      
      return {
        id: typeof frame.id === "string" ? frame.id : `${currentNode.id}-frame-${idx}`,
        ...frame,
        speaker: frame.speaker ?? "",
        text: frame.text ?? "",
        sprite,
        bg: typeof currentNode.assets?.bg === "string" ? currentNode.assets.bg : undefined
      };
    }) || [];

    return (
      <div className="min-h-screen bg-gradient-to-b from-background to-primary/5 p-4" style={rootStyle}>
        <div className="max-w-6xl mx-auto py-8">
          <div className="flex gap-2 mb-4">
            <Button
              onClick={handleBackToLevelSelection}
              variant="ghost"
              size="sm"
              className="gap-2"
            >
              ‚Üê Ch·ªçn m√†n
            </Button>
            <Button
              onClick={handleExit}
              variant="ghost"
              size="sm"
              className="gap-2"
            >
              <ArrowLeft className="w-4 h-4" />
              Quay v·ªÅ
            </Button>
          </div>
          
          <CutscenePlayer
            frames={enhancedFrames}
            onComplete={handleCutsceneComplete}
            onSkip={handleCutsceneSkip}
          />
        </div>
      </div>
    );
  }

  // Questions Phase
  if (gamePhase === "questions" && currentNode) {
    // Ensure activity is loaded
    if (!currentActivity) {
      console.warn("Activity not loaded, loading now...");
      const activity = getActivity(currentNode.activityRef);
      if (activity) {
        setCurrentActivity(activity as SimpleActivity);
      }
      return (
        <div className="min-h-screen flex items-center justify-center bg-background" style={rootStyle}>
          <div className="flex flex-col items-center gap-4">
            <Loader2 className="h-8 w-8 animate-spin text-primary" />
            <p>ƒêang t·∫£i c√¢u h·ªèi...</p>
          </div>
        </div>
      );
    }
    
    const currentQuestionRaw = currentActivity.questions?.[currentQuestionIndex];
    
    if (!currentQuestionRaw) {
      console.error("No question found at index:", currentQuestionIndex);
      return (
        <div className="min-h-screen flex items-center justify-center bg-background" style={rootStyle}>
          <div className="flex flex-col items-center gap-4">
            <p className="text-red-500">Kh√¥ng t√¨m th·∫•y c√¢u h·ªèi!</p>
            <Button onClick={handleBackToLevelSelection}>Quay v·ªÅ ch·ªçn m√†n</Button>
          </div>
        </div>
      );
    }
    
    const currentQuestion = normalizeQuestion(currentQuestionRaw, currentQuestionIndex) as unknown as { 
      id: string; 
      question: string; 
      options: string[]; 
      correctAnswer: number; 
      type: "multiple-choice" | "matching-pairs" | "drag-drop" | "fill-blank" | "counting"; 
      [key: string]: unknown;
    };
    
    // Check if question is valid - support both legacy and new formats
    const hasOptions = currentQuestion.options && currentQuestion.options.length > 0;
    const hasSpecialType = currentQuestion.type && 
      (currentQuestion.type === "matching-pairs" || 
       currentQuestion.type === "drag-drop" || 
       currentQuestion.type === "fill-blank" || 
       currentQuestion.type === "counting");
    
    if (!currentQuestion || (!hasOptions && !hasSpecialType)) {
      console.error("Invalid question format:", currentQuestion, "Index:", currentQuestionIndex, "Total:", currentActivity.questions.length);
      return (
        <div className="min-h-screen flex items-center justify-center bg-background" style={rootStyle}>
          <div className="flex flex-col items-center gap-4">
            <p className="text-red-500">L·ªói: Kh√¥ng th·ªÉ t·∫£i c√¢u h·ªèi {currentQuestionIndex + 1}</p>
            <Button onClick={handleBackToLevelSelection}>Quay v·ªÅ ch·ªçn m√†n</Button>
          </div>
        </div>
      );
    }

    return (
      <div className="min-h-screen bg-gradient-to-b from-background to-primary/5" style={rootStyle}>
        <GameHud
          levelTitle={currentNode.title}
          totalXp={earnedXpThisLevel}
          maxXp={currentActivity.questions.length * (currentActivity.xpReward || 10)}
          correctCount={correctThisLevel}
          incorrectCount={incorrectThisLevel}
          timerSeconds={timerSeconds}
          onTimeUp={handleTimeUp}
          onBack={handleBackToLevelSelection}
        />
        
        <div className="max-w-7xl mx-auto p-4 md:p-8 pt-4">
          <QuestionCard
            question={currentQuestion}
            questionNumber={currentQuestionIndex + 1}
            totalQuestions={currentActivity.questions.length}
            onAnswer={handleAnswer}
          />
        </div>

        <BadgeModal
          isOpen={showBadgeModal}
          badgeId={completedBadgeId}
          earnedXp={earnedXpThisLevel}
          performance={levelPerformance}
          onContinue={handleBadgeModalContinue}
          onRetry={levelPerformance === "retry" ? handleRetry : undefined}
        />
        
        {isSubmitting && (
          <div className="fixed inset-0 bg-background/80 backdrop-blur-sm flex items-center justify-center z-50">
            <div className="flex flex-col items-center gap-4 bg-card p-8 rounded-lg shadow-lg border">
              <Loader2 className="h-12 w-12 animate-spin text-primary" />
              <p className="text-lg font-medium">ƒêang l∆∞u k·∫øt qu·∫£...</p>
              <p className="text-sm text-muted-foreground">Vui l√≤ng ƒë·ª£i trong gi√¢y l√°t</p>
            </div>
          </div>
        )}
      </div>
    );
  }

  return (
    <div className="min-h-screen flex items-center justify-center" style={rootStyle}>
      <div className="flex flex-col items-center gap-4">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
        <p>ƒêang t·∫£i...</p>
      </div>
    </div>
  );
};
